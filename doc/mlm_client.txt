mlm_client(3)
=============

NAME
----
mlm_client - Malamute client stack

SYNOPSIS
--------
----
//  This API is a draft, and may change without notice.
#ifdef MLM_BUILD_DRAFT_API
//  *** Draft method, for development use, may change without warning ***
//  Create a new mlm_client, return the reference if successful,   
//  or NULL if construction failed due to lack of available memory.
MLM_EXPORT mlm_client_t *
    mlm_client_new (void);

//  *** Draft method, for development use, may change without warning ***
//  Destroy the mlm_client and free all memory used by the object.
MLM_EXPORT void
    mlm_client_destroy (mlm_client_t **self_p);

//  *** Draft method, for development use, may change without warning ***
//  Return actor, when caller wants to work with multiple actors and/or
//  input sockets asynchronously.                                      
MLM_EXPORT zactor_t *
    mlm_client_actor (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return message pipe for asynchronous message I/O. In the high-volume case,
//  we send methods and get replies to the actor, in a synchronous manner, and
//  we send/recv high volume message data to a second pipe, the msgpipe. In   
//  the low-volume case we can do everything over the actor pipe, if traffic  
//  is never ambiguous.                                                       
MLM_EXPORT zsock_t *
    mlm_client_msgpipe (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return true if client is currently connected, else false. Note that the   
//  client will automatically re-connect if the server dies and restarts after
//  a successful first connection.                                            
MLM_EXPORT bool
    mlm_client_connected (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Set PLAIN authentication username and password. If you do not call this, the    
//  client will use NULL authentication. TODO: add "set curve auth".                
//  Returns >= 0 if successful, -1 if interrupted.                                  
MLM_EXPORT int
    mlm_client_set_plain_auth (mlm_client_t *self, const char *username, const char *password);

//  *** Draft method, for development use, may change without warning ***
//  Connect to server endpoint, with specified timeout in msecs (zero means wait    
//  forever). Constructor succeeds if connection is successful. The caller may      
//  specify its address.                                                            
//  Returns >= 0 if successful, -1 if interrupted.                                  
MLM_EXPORT int
    mlm_client_connect (mlm_client_t *self, const char *endpoint, uint32_t timeout, const char *address);

//  *** Draft method, for development use, may change without warning ***
//  Prepare to publish to a specified stream. After this, all messages are sent to  
//  this stream exclusively.                                                        
//  Returns >= 0 if successful, -1 if interrupted.                                  
MLM_EXPORT int
    mlm_client_set_producer (mlm_client_t *self, const char *stream);

//  *** Draft method, for development use, may change without warning ***
//  Consume messages with matching subjects. The pattern is a regular expression    
//  using the CZMQ zrex syntax. The most useful elements are: ^ and $ to match the  
//  start and end, . to match any character, \s and \S to match whitespace and      
//  non-whitespace, \d and \D to match a digit and non-digit, \a and \A to match    
//  alphabetic and non-alphabetic, \w and \W to match alphanumeric and              
//  non-alphanumeric, + for one or more repetitions, * for zero or more repetitions,
//  and ( ) to create groups. Returns 0 if subscription was successful, else -1.    
//  Returns >= 0 if successful, -1 if interrupted.                                  
MLM_EXPORT int
    mlm_client_set_consumer (mlm_client_t *self, const char *stream, const char *pattern);

//  *** Draft method, for development use, may change without warning ***
//  Offer a particular named service, where the pattern matches request subjects    
//  using the CZMQ zrex syntax.                                                     
//  Returns >= 0 if successful, -1 if interrupted.                                  
MLM_EXPORT int
    mlm_client_set_worker (mlm_client_t *self, const char *address, const char *pattern);

//  *** Draft method, for development use, may change without warning ***
//  Send STREAM SEND message to server, takes ownership of message
//  and destroys message when done sending it.                    
MLM_EXPORT int
    mlm_client_send (mlm_client_t *self, const char *subject, zmsg_t **content);

//  *** Draft method, for development use, may change without warning ***
//  Send MAILBOX SEND message to server, takes ownership of message
//  and destroys message when done sending it.                     
MLM_EXPORT int
    mlm_client_sendto (mlm_client_t *self, const char *address, const char *subject, const char *tracker, uint32_t timeout, zmsg_t **content);

//  *** Draft method, for development use, may change without warning ***
//  Send SERVICE SEND message to server, takes ownership of message
//  and destroys message when done sending it.                     
MLM_EXPORT int
    mlm_client_sendfor (mlm_client_t *self, const char *address, const char *subject, const char *tracker, uint32_t timeout, zmsg_t **content);

//  *** Draft method, for development use, may change without warning ***
//  Receive message from server; caller destroys message when done
MLM_EXPORT zmsg_t *
    mlm_client_recv (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received command. Can be one of these values:
//      "STREAM DELIVER"                                     
//      "MAILBOX DELIVER"                                    
//      "SERVICE DELIVER"                                    
MLM_EXPORT const char *
    mlm_client_command (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received status
MLM_EXPORT int
    mlm_client_status (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received reason
MLM_EXPORT const char *
    mlm_client_reason (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received address
MLM_EXPORT const char *
    mlm_client_address (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received sender
MLM_EXPORT const char *
    mlm_client_sender (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received subject
MLM_EXPORT const char *
    mlm_client_subject (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received content
MLM_EXPORT zmsg_t *
    mlm_client_content (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Return last received tracker
MLM_EXPORT const char *
    mlm_client_tracker (mlm_client_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Send multipart string message to stream, end list with NULL        
//  Returns 0 if OK, -1 if failed due to lack of memory or other error.
MLM_EXPORT int
    mlm_client_sendx (mlm_client_t *self, const char *subject, const char *content, ...);

//  *** Draft method, for development use, may change without warning ***
//  Send multipart string to mailbox, end list with NULL               
//  Returns 0 if OK, -1 if failed due to lack of memory or other error.
MLM_EXPORT int
    mlm_client_sendtox (mlm_client_t *self, const char *address, const char *subject, const char *content, ...);

//  *** Draft method, for development use, may change without warning ***
//  Send multipart string to service, end list with NULL               
//  Returns 0 if OK, -1 if failed due to lack of memory or other error.
MLM_EXPORT int
    mlm_client_sendforx (mlm_client_t *self, const char *address, const char *subject, const char *content, ...);

//  *** Draft method, for development use, may change without warning ***
//  Receive a subject and string content from the server. The content may be
//  1 or more string frames. This method is orthogonal to the sendx methods.
//  End the string arguments with NULL. If there are not enough frames in   
//  the received message, remaining strings are set to NULL. Returns number 
//  of string contents received, or -1 in case of error. Free the returned  
//  subject and content strings when finished with them. To get the type of 
//  the command, use mlm_client_command ().                                 
MLM_EXPORT int
    mlm_client_recvx (mlm_client_t *self, char **subject_p, char **string_p, ...);

//  *** Draft method, for development use, may change without warning ***
//  Enable verbose tracing (animation) of state machine activity.
MLM_EXPORT void
    mlm_client_set_verbose (mlm_client_t *self, bool verbose);

//  *** Draft method, for development use, may change without warning ***
//  Self test of this class.
MLM_EXPORT void
    mlm_client_test (bool verbose);

#endif // MLM_BUILD_DRAFT_API
Please add '@interface' section in './../src/mlm_client.c'.
----

DESCRIPTION
-----------

Provides an async client API to the Malamute Protocol.

Please add '@discuss' section in './../src/mlm_client.c'.

EXAMPLE
-------
.From mlm_client_test method
----

//  Start a server to test against, and bind to endpoint
zactor_t *server = zactor_new (mlm_server, "mlm_stream_api_test");
assert (server);
if (verbose) {
    rc = zstr_send (server, "VERBOSE");
    assert (rc != -1);
}
rc = zstr_sendx (server, "BIND", endpoint, NULL);
assert (rc != -1);

// create client broadcast source in writer
mlm_client_t *writer = mlm_client_new ();
assert (writer);
mlm_client_set_verbose (writer, verbose);
assert (mlm_client_connected (writer) == false);

// connect to publishing end of the broadcast channel
rc = mlm_client_connect (writer, endpoint, 1000, "writer");
assert (rc == 0);
assert (mlm_client_connected (writer) == true);
// set writer to broadcast to channel "weather"
rc = mlm_client_set_producer (writer, "weather");
assert (rc == 0);

// start broadcasting temp messages - these will be lost, since our reader is not yet established
rc = mlm_client_sendx (writer, "temp.moscow", "1", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.moscow", "2", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.madrid", "3", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.madrid", "4", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.london", "5", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.london", "6", NULL);
assert (rc == 0);

// create client broadcast sink in reader
mlm_client_t *reader = mlm_client_new ();
assert (reader);
mlm_client_set_verbose (reader, verbose);
// connect to subscribing end of the broadcast channel
rc = mlm_client_connect (reader, endpoint, 1000, "");
assert (rc == 0);
// set reader to only pay attention to "temp.*" messages on the "weather" channel
rc = mlm_client_set_consumer (reader, "weather", "temp.*");
assert (rc == 0);

// start broadcasting temp messages - these will be received
rc = mlm_client_sendx (writer, "temp.moscow", "11", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.moscow", "12", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.madrid", "13", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.madrid", "14", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.london", "15", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.london", "16", NULL);
assert (rc == 0);

// receive interesting broadcast messages (only the "temp.*" ones)
rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.moscow"));
assert (streq (content, "11"));
assert (streq (mlm_client_command (reader), "STREAM DELIVER"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.madrid"));
assert (streq (content, "13"));
assert (streq (mlm_client_command (reader), "STREAM DELIVER"));
assert (streq (mlm_client_subject (reader), "temp.madrid"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.london"));
assert (streq (content, "15"));
assert (streq (mlm_client_command (reader), "STREAM DELIVER"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

// partial shutdown - client only
mlm_client_destroy (&reader);

// start broadcasting temp messages - these will not be received either
rc = mlm_client_sendx (writer, "temp.moscow", "21", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.moscow", "22", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.madrid", "23", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.madrid", "24", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.london", "25", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.london", "26", NULL);
assert (rc == 0);

//  Done, shut down
mlm_client_destroy (&writer);
zactor_destroy (&server);


//  Start a server to test against, and bind to endpoint
zactor_t *server = zactor_new (mlm_server, "mlm_service_api_test");
assert (server);
if (verbose) {
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
const char *endpoint = "ipc://mlm_service_api_server";
rc = zstr_sendx (server, "BIND", endpoint, NULL);
assert (rc == 0);

//  create service requester
mlm_client_t *requester = mlm_client_new ();
assert (requester);
mlm_client_set_verbose (requester, verbose);
assert (mlm_client_connected (requester) == false);
// try to connect to server that doesn't exist
rc = mlm_client_connect (requester, "nonsence",1000, "writes");
assert (rc == -1);
assert (mlm_client_connected (requester) == false);
// try to connect to other server, that should exist.
rc = mlm_client_connect (requester, endpoint, 1000, "requester_address");
assert (rc == 0);
assert (mlm_client_connected (requester) == true);

//    mlm_client_set_producer (requester, "weather");

mlm_client_t *worker = mlm_client_new ();
assert (worker);
mlm_client_set_verbose (worker, verbose);
rc = mlm_client_connect (worker, endpoint, 500, "mailbox");
assert (rc == 0);

//  Test service pattern
rc = mlm_client_set_worker (worker, "printer_service", "bw.*");
assert (rc == 0);
rc = mlm_client_set_worker (worker, "printer_service", "color.*");
assert (rc == 0);

rc = mlm_client_sendforx (requester, "printer_service", "bw.A4", "Important contract", NULL);
assert (rc == 0);
rc = mlm_client_sendforx (requester, "printer_service", "bw.A5", "Special conditions", NULL);
assert (rc == 0);

rc = mlm_client_recvx (worker, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "bw.A4"));
assert (streq (content, "Important contract"));
assert (streq (mlm_client_command (worker), "SERVICE DELIVER"));
assert (streq (mlm_client_sender (worker), "requester_address"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (worker, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "bw.A5"));
assert (streq (content, "Special conditions"));
assert (streq (mlm_client_command (worker), "SERVICE DELIVER"));
assert (streq (mlm_client_sender (worker), "requester_address"));
zstr_free (&subject);
zstr_free (&content);

//  Test that writer shutdown does not cause message loss
rc = mlm_client_sendforx (requester, "printer_service", "bw.A6", "Destroyed requester", NULL);
assert (rc == 0);
mlm_client_destroy (&requester);

rc = mlm_client_recvx (worker, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "bw.A6"));
assert (streq (content, "Destroyed requester"));
assert (streq (mlm_client_command (worker), "SERVICE DELIVER"));
assert (streq (mlm_client_sender (worker), "requester_address"));
zstr_free (&subject);
zstr_free (&content);
mlm_client_destroy (&worker);

//  Done, shut down
zactor_destroy (&server);

//  Start a server to test against, and bind to endpoint
zactor_t *server = zactor_new (mlm_server, "mlm_services_api_test");
assert (server != NULL);
if (verbose) {
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
const char *endpoint = "ipc://mlm_services_api_server";
rc = zstr_sendx (server, "BIND", endpoint, NULL);
assert (rc == 0);

// create requesters
mlm_client_t *requester1 = mlm_client_new ();
assert (requester1);
mlm_client_set_verbose (requester1, verbose);
rc = mlm_client_connect (requester1, endpoint, 1000, "requester_address_1");
assert (rc == 0);
assert (mlm_client_connected (requester1) == true);

mlm_client_t *requester2 = mlm_client_new ();
assert (requester2);
mlm_client_set_verbose (requester2, verbose);
rc = mlm_client_connect (requester2, endpoint, 1000, "requester_address_2");
assert (rc == 0);
assert (mlm_client_connected (requester2) == true);

// create workers
mlm_client_t *worker1 = mlm_client_new ();
assert (worker1);
mlm_client_set_verbose (worker1, verbose);
rc = mlm_client_connect (worker1, endpoint, 1000, "worker1");
assert (rc == 0);
assert (mlm_client_connected (worker1) == true);
rc = mlm_client_set_worker (worker1, "print_service_address", "bw.*");
assert (rc == 0);

mlm_client_t *worker2 = mlm_client_new ();
assert (worker2);
mlm_client_set_verbose (worker2, verbose);
rc = mlm_client_connect (worker2, endpoint, 1000, "worker2");
assert (rc == 0);
assert (mlm_client_connected (worker2) == true);
rc = mlm_client_set_worker (worker2, "print_service_address", "bw.*");
assert (rc == 0);

// define that requesters will generate printJob events
rc = mlm_client_set_producer (requester1, "print_service_stream");
assert (rc == 0);
rc = mlm_client_set_producer (requester2, "print_service_stream");
assert (rc == 0);
// define that workers will listen to printJob events related to requests
rc = mlm_client_set_consumer (worker1, "print_service_stream", "request.*");
assert (rc == 0);
rc = mlm_client_set_consumer (worker2, "print_service_stream", "request.*");
assert (rc == 0);

rc = mlm_client_sendx (requester1, "request", "start", NULL);
assert (rc == 0);

rc = mlm_client_recvx (worker1, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "request"));
assert (streq (content, "start"));
assert (mlm_client_status (worker1) == 0);
assert (streq (mlm_client_command (worker1), "STREAM DELIVER"));
assert (mlm_client_reason (worker1) == NULL);
assert (streq (mlm_client_address (worker1), "print_service_stream"));
assert (streq (mlm_client_sender (worker1), "requester_address_1"));
assert (streq (mlm_client_subject (worker1), "request"));
assert (mlm_client_tracker (worker1) == NULL);
zstr_free (&subject);
assert (subject == NULL);
zstr_free (&content);
assert (content == NULL);

rc = mlm_client_recvx (worker2, &subject, &content, NULL);
assert (rc != -1);
assert (streq (mlm_client_address (worker2), "print_service_stream"));
assert (streq (subject, "request"));
assert (streq (content, "start"));
zstr_free (&subject);
assert (subject == NULL);
zstr_free (&content);
assert (content == NULL);


//  Test service pattern using two requesters and two workers
rc = mlm_client_sendforx (requester1, "print_service_address", "bw.A4", "Important contract", NULL);
assert (rc == 0);
rc = mlm_client_sendforx (requester2, "print_service_address", "bw.A5", "Special conditions", NULL);
assert (rc == 0);

rc = mlm_client_recvx (worker1, &subject, &content, NULL);
assert (rc != -1);
bool isFirst = false;
if (streq (subject, "bw.A4")) {
    assert (streq (mlm_client_sender (worker1), "requester_address_1"));
    assert (streq (content, "Important contract"));
    isFirst = true;
} else {
    assert (streq (subject, "bw.A5"));
    assert (streq (mlm_client_sender (worker1), "requester_address_2"));
    assert (streq (content, "Special conditions"));
}
assert (streq (mlm_client_command (worker1), "SERVICE DELIVER"));
assert (streq (mlm_client_address (worker1), "print_service_address"));
assert (streq (mlm_client_subject (worker1), subject));
assert (streq (mlm_client_tracker (worker1), ""));
assert (mlm_client_reason (worker1) == NULL);
zstr_free (&subject);
assert (subject == NULL);
zstr_free (&content);
assert (content == NULL);

rc = mlm_client_recvx (worker2, &subject, &content, NULL);
assert (rc != -1);
if ( isFirst ) {
    assert (streq (subject, "bw.A5"));
    assert (streq (content, "Special conditions"));
    assert (streq (mlm_client_sender (worker2), "requester_address_2"));
} else {
    assert (streq (subject, "bw.A4"));
    assert (streq (mlm_client_sender (worker2), "requester_address_1"));
    assert (streq (content, "Important contract"));
}
assert (streq (mlm_client_command (worker2), "SERVICE DELIVER"));
assert (streq (mlm_client_address (worker2), "print_service_address"));
assert (streq (mlm_client_subject (worker2), subject));
assert (streq (mlm_client_tracker (worker2), ""));
assert (mlm_client_reason (worker2) == NULL);
zstr_free (&subject);
assert (subject == NULL);
zstr_free (&content);
assert (content == NULL);

// generate event to tell workers work is done
rc = mlm_client_sendx (requester2, "request", "stop", NULL);
assert (rc == 0);

rc = mlm_client_recvx (worker1, &subject, &content, NULL);
assert (rc != -1);
assert (mlm_client_status (worker1) == 0);
assert (streq (mlm_client_command (worker1), "STREAM DELIVER"));
assert (streq (mlm_client_address (worker1), "print_service_stream"));
assert (streq (mlm_client_sender (worker1), "requester_address_2"));
assert (streq (mlm_client_subject (worker1), "request"));
assert (streq (mlm_client_tracker (worker1), ""));
assert (mlm_client_reason (worker1) == NULL);
assert (streq (subject, "request"));
assert (streq (content, "stop"));
zstr_free (&subject);
assert (subject == NULL);
zstr_free (&content);
assert (content == NULL);

rc = mlm_client_recvx (worker2, &subject, &content, NULL);
assert (rc != -1);
assert (streq (mlm_client_command (worker2), "STREAM DELIVER"));
assert (streq (mlm_client_address (worker2), "print_service_stream"));
assert (streq (mlm_client_sender (worker2), "requester_address_2"));
assert (streq (mlm_client_subject (worker2), "request"));
assert (streq (mlm_client_tracker (worker2), ""));
assert (mlm_client_reason (worker2) == NULL);
assert (streq (subject, "request"));
assert (streq (content, "stop"));
zstr_free (&subject);
assert (subject == NULL);
zstr_free (&content);
assert (content == NULL);

mlm_client_destroy (&worker1);
assert (worker1 == NULL);
mlm_client_destroy (&worker2);
assert (worker2 == NULL);
mlm_client_destroy (&requester1);
assert (requester1 == NULL);
mlm_client_destroy (&requester2);
assert (requester2 == NULL);

//  Done, shut down
zactor_destroy (&server);

//  Test api, when client is not connected at all
mlm_client_t *client = mlm_client_new ();
assert (client);
mlm_client_set_verbose (client, verbose);
assert (mlm_client_connected (client) == false);
int rc = mlm_client_set_producer (client, "weather");
assert (mlm_client_connected (client) == false);
assert ( rc == -1 );
rc = mlm_client_set_consumer (client, "weather", ".*");
assert (mlm_client_connected (client) == false);
assert ( rc == -1 );
rc = mlm_client_set_worker (client, "weather", ".*");
assert (mlm_client_connected (client) == false);
assert ( rc == -1 );
mlm_client_destroy (&client);

//  Start a server to test against, and bind to endpoint
//  this instance of the server is going to be be killed
zactor_t *server = zactor_new (mlm_server, "mlm_client_test");
assert (server);
if (verbose)
{
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
rc = zstr_sendx (server, "LOAD", "src/mlm_client.cfg", NULL);
assert (rc == 0);
const char *endpoint = "tcp://127.0.0.1:9999";
//  Install authenticator to test PLAIN access
zactor_t *auth = zactor_new (zauth, NULL);
assert (auth);
if (verbose) {
    rc = zstr_sendx (auth, "VERBOSE", NULL);
    assert (rc == 0);
    rc = zsock_wait (auth);
    assert (rc == 0);
}
rc = zstr_sendx (auth, "PLAIN", "src/passwords.cfg", NULL);
assert (rc == 0);
rc = zsock_wait (auth);
assert (rc == 0);

// Test the robustness of the client, againt server failure
client = mlm_client_new ();
assert (client);
mlm_client_set_verbose (client, verbose);
rc = mlm_client_set_plain_auth (client, "writer", "secret");
assert ( rc == 0 );
rc = mlm_client_connect (client, endpoint, 1000, "client_robust");
assert ( rc == 0 );

// Test, that issues with regexp are reported correctly
rc = mlm_client_set_consumer (client, "MY_STREAM_WITH_BAD_PATTERN", "[");
assert ( rc == -1 );

//      stop the server
zactor_destroy (&server);

rc = mlm_client_set_producer (client, "new_stream");
assert ( rc == -1 );
rc = mlm_client_set_consumer (client, "new_stream", ".*");
assert ( rc == -1 );
rc = mlm_client_set_worker (client, "new_stream", ".*");
assert ( rc == -1 );
assert ( mlm_client_connected (client) == false);
mlm_client_set_verbose (client, verbose);
mlm_client_destroy (&client);

// Test the ability to reconnect to the server, if the server returns soon
server = zactor_new (mlm_server, "mlm_client_test");
assert (server);
if (verbose)
{
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
rc = zstr_sendx (server, "LOAD", "src/mlm_client.cfg", NULL);
assert (rc == 0);

client = mlm_client_new ();
assert (client);
mlm_client_set_verbose (client, verbose);
rc = mlm_client_set_plain_auth (client, "writer", "secret");
assert ( rc == 0 );
rc = mlm_client_connect (client, endpoint, 1000, "client_reconnect");
assert ( rc == 0 );
//      stop the server
zactor_destroy (&server);
//      and return it
server = zactor_new (mlm_server, "mlm_client_test");
assert (server);
if (verbose)
{
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
rc = zstr_sendx (server, "LOAD", "src/mlm_client.cfg", NULL);
assert (rc == 0);
rc = mlm_client_set_producer (client, "new_stream");
assert ( rc == -1 ); // the  method set producer is called too fast,
// so, the client didn't manage to establish a new connection with
// the newly appeared server
zclock_sleep (5000); // wait a bit
// after a while we are connected again
assert (mlm_client_connected (client) == true );

rc = mlm_client_set_consumer (client, "new_stream", ".*");
assert ( rc == 0 );
rc = mlm_client_set_worker (client, "new_stream", ".*");
assert ( rc == 0 );
zactor_destroy (&server);
mlm_client_destroy (&client);

// Test the ability to reconnect to the server, if the server returns when
// the client is already in disconnected state
server = zactor_new (mlm_server, "mlm_client_test");
assert (server);
if (verbose)
{
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
rc = zstr_sendx (server, "LOAD", "src/mlm_client.cfg", NULL);
assert (rc == 0);

client = mlm_client_new ();
assert (client);
mlm_client_set_verbose (client, verbose);
rc = mlm_client_set_plain_auth (client, "writer", "secret");
assert ( rc == 0 );
rc = mlm_client_connect (client, endpoint, 1000, "client_reconnect");
assert ( rc == 0 );
//      stop the server
zactor_destroy (&server);
zclock_sleep (10000); // wait a bit
assert (mlm_client_connected (client) == false);
//      and return it
server = zactor_new (mlm_server, "mlm_client_test");
assert (server);
if (verbose)
{
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
rc = zstr_sendx (server, "LOAD", "src/mlm_client.cfg", NULL);
assert (rc == 0);
zclock_sleep (5000); // wait a bit
// after a while we are connected again
assert (mlm_client_connected (client) == true);

rc = mlm_client_set_consumer (client, "new_stream", ".*");
assert ( rc == 0 );
rc = mlm_client_set_worker (client, "new_stream", ".*");
assert ( rc == 0 );
zactor_destroy (&server);
mlm_client_destroy (&client);

//  Start a server to test against, and bind to endpoint
server = zactor_new (mlm_server, "mlm_client_test");
assert (server);
if (verbose)
{
    rc = zstr_send (server, "VERBOSE");
    assert (rc == 0);
}
rc = zstr_sendx (server, "LOAD", "src/mlm_client.cfg", NULL);
assert (rc == 0);

//  Test stream pattern
mlm_client_t *writer = mlm_client_new ();
assert (writer);
mlm_client_set_verbose (writer, verbose);
rc = mlm_client_set_plain_auth (writer, "writer", "secret");
assert (rc == 0);
assert (mlm_client_connected (writer) == false);
// try to connect to server that doesn't exist
rc = mlm_client_connect (writer, "nonsence",1000, "writes");
assert (rc == -1);
assert (mlm_client_connected (writer) == false);
// try to connect to other server, that should exist.
rc = mlm_client_connect (writer, endpoint, 1000, "writer");
assert (rc == 0);
assert (mlm_client_connected (writer) == true);

mlm_client_t *reader = mlm_client_new ();
assert (reader);
mlm_client_set_verbose (reader, verbose);
rc = mlm_client_set_plain_auth (reader, "reader", "secret");
assert (rc == 0);
rc = mlm_client_connect (reader, endpoint, 1000, "");
assert (rc == 0);

rc = mlm_client_set_producer (writer, "weather");
assert (rc == 0);
rc = mlm_client_set_consumer (reader, "weather", "temp.*");
assert (rc == 0);

rc = mlm_client_sendx (writer, "temp.moscow", "1", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.moscow", "2", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.madrid", "3", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.madrid", "4", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "temp.london", "5", NULL);
assert (rc == 0);
rc = mlm_client_sendx (writer, "rain.london", "6", NULL);
assert (rc == 0);

char *subject, *content;
rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.moscow"));
assert (streq (content, "1"));
assert (streq (mlm_client_command (reader), "STREAM DELIVER"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.madrid"));
assert (streq (content, "3"));
assert (streq (mlm_client_command (reader), "STREAM DELIVER"));
assert (streq (mlm_client_subject (reader), "temp.madrid"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.london"));
assert (streq (content, "5"));
assert (streq (mlm_client_command (reader), "STREAM DELIVER"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

mlm_client_destroy (&reader);

//  Test mailbox pattern
reader = mlm_client_new ();
assert (reader);
mlm_client_set_verbose (reader, verbose);
rc = mlm_client_set_plain_auth (reader, "reader", "secret");
assert (rc == 0);
rc = mlm_client_connect (reader, endpoint, 1000, "mailbox");
assert (rc == 0);

rc = mlm_client_sendtox (writer, "mailbox", "subject 1", "Message 1", "attachment", NULL);
assert (rc != -1);

char *attach;
rc = mlm_client_recvx (reader, &subject, &content, &attach, NULL);
assert (rc != -1);
assert (streq (subject, "subject 1"));
assert (streq (content, "Message 1"));
assert (streq (attach, "attachment"));
assert (streq (mlm_client_command (reader), "MAILBOX DELIVER"));
assert (streq (mlm_client_subject (reader), "subject 1"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);
zstr_free (&attach);

//  Now test that mailbox survives reader disconnect
mlm_client_destroy (&reader);
rc = mlm_client_sendtox (writer, "mailbox", "subject 2", "Message 2", NULL);
assert (rc != -1);
rc = mlm_client_sendtox (writer, "mailbox", "subject 3", "Message 3", NULL);
assert (rc != -1);

reader = mlm_client_new ();
assert (reader);
mlm_client_set_verbose (reader, verbose);
rc = mlm_client_set_plain_auth (reader, "reader", "secret");
assert (rc == 0);
rc = mlm_client_connect (reader, endpoint, 500, "mailbox");
assert (rc == 0);

rc = mlm_client_recvx (reader, &subject, &content, &attach, NULL);
assert (rc != -1);
assert (streq (subject, "subject 2"));
assert (streq (content, "Message 2"));
assert (streq (mlm_client_command (reader), "MAILBOX DELIVER"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader, &subject, &content, &attach, NULL);
assert (rc != -1);
assert (streq (subject, "subject 3"));
assert (streq (content, "Message 3"));
assert (streq (mlm_client_command (reader), "MAILBOX DELIVER"));
zstr_free (&subject);
zstr_free (&content);

//  Test service pattern
rc = mlm_client_set_worker (reader, "printer", "bw.*");
assert (rc != -1);
rc = mlm_client_set_worker (reader, "printer", "color.*");
assert (rc != -1);

rc = mlm_client_sendforx (writer, "printer", "bw.A4", "Important contract", NULL);
assert (rc != -1);
rc = mlm_client_sendforx (writer, "printer", "bw.A5", "Special conditions", NULL);
assert (rc != -1);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "bw.A4"));
assert (streq (content, "Important contract"));
assert (streq (mlm_client_command (reader), "SERVICE DELIVER"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "bw.A5"));
assert (streq (content, "Special conditions"));
assert (streq (mlm_client_command (reader), "SERVICE DELIVER"));
assert (streq (mlm_client_sender (reader), "writer"));
zstr_free (&subject);
zstr_free (&content);

//  Test that writer shutdown does not cause message loss
rc = mlm_client_set_consumer (reader, "weather", "temp.*");
assert (rc != -1);
rc = mlm_client_sendx (writer, "temp.brussels", "7", NULL);
assert (rc != -1);
mlm_client_destroy (&writer);

rc = mlm_client_recvx (reader, &subject, &content, NULL);
assert (rc != -1);
assert (streq (subject, "temp.brussels"));
assert (streq (content, "7"));
zstr_free (&subject);
zstr_free (&content);
mlm_client_destroy (&reader);

//  Test multiple readers and multiple writers
mlm_client_t *writer1 = mlm_client_new ();
assert (writer1);
mlm_client_set_verbose (writer1, verbose);
rc = mlm_client_set_plain_auth (writer1, "writer", "secret");
assert (rc == 0);
rc = mlm_client_connect (writer1, endpoint, 1000, "");
assert (rc == 0);

mlm_client_t *writer2 = mlm_client_new ();
assert (writer2);
mlm_client_set_verbose (writer2, verbose);
rc = mlm_client_set_plain_auth (writer2, "writer", "secret");
assert (rc == 0);
rc = mlm_client_connect (writer2, endpoint, 1000, "");
assert (rc == 0);

mlm_client_t *reader1 = mlm_client_new ();
assert (reader1);
mlm_client_set_verbose (reader1, verbose);
rc = mlm_client_set_plain_auth (reader1, "reader", "secret");
assert (rc == 0);
rc = mlm_client_connect (reader1, endpoint, 1000, "");
assert (rc == 0);

mlm_client_t *reader2 = mlm_client_new ();
assert (reader2);
mlm_client_set_verbose (reader2, verbose);
rc = mlm_client_set_plain_auth (reader2, "reader", "secret");
assert (rc == 0);
rc = mlm_client_connect (reader2, endpoint, 1000, "");
assert (rc == 0);

rc = mlm_client_set_producer (writer1, "weather");
assert (rc != -1);
rc = mlm_client_set_producer (writer2, "traffic");
assert (rc != -1);
rc = mlm_client_set_consumer (reader1, "weather", "newyork");
assert (rc != -1);
rc = mlm_client_set_consumer (reader1, "traffic", "newyork");
assert (rc != -1);
rc = mlm_client_set_consumer (reader2, "weather", "newyork");
assert (rc != -1);
rc = mlm_client_set_consumer (reader2, "traffic", "newyork");
assert (rc != -1);

rc = mlm_client_sendx (writer1, "newyork", "8", NULL);
assert (rc != -1);

rc = mlm_client_recvx (reader1, &subject, &content, NULL);
assert (rc != -1);
assert (streq (mlm_client_address (reader1), "weather"));
assert (streq (subject, "newyork"));
assert (streq (content, "8"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader2, &subject, &content, NULL);
assert (rc != -1);
assert (streq (mlm_client_address (reader2), "weather"));
assert (streq (subject, "newyork"));
assert (streq (content, "8"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_sendx (writer2, "newyork", "85", NULL);
assert (rc != -1);

rc = mlm_client_recvx (reader1, &subject, &content, NULL);
assert (rc != -1);
assert (streq (mlm_client_address (reader1), "traffic"));
assert (streq (subject, "newyork"));
assert (streq (content, "85"));
zstr_free (&subject);
zstr_free (&content);

rc = mlm_client_recvx (reader2, &subject, &content, NULL);
assert (rc != -1);
assert (streq (mlm_client_address (reader2), "traffic"));
assert (streq (subject, "newyork"));
assert (streq (content, "85"));
zstr_free (&subject);
zstr_free (&content);


mlm_client_destroy (&writer1);
mlm_client_destroy (&writer2);
mlm_client_destroy (&reader1);
mlm_client_destroy (&reader2);

//  Done, shut down
zactor_destroy (&auth);
zactor_destroy (&server);
----
